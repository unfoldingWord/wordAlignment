import _ from 'lodash';
import {numberComparator, objectComparator} from './index';

/**
 * Generates an index of tokens that will be rendered.
 * @param {object[]} alignments - an array of alignments
 * @param {object[]} suggestions - an array of suggestions
 * @return {{source: Array, target: Array}}
 */
export const indexTokens = (alignments, suggestions) => {
  const sourceTokenIndex = [];
  const targetTokenIndex = [];
  const alignmentIndex = [];
  const suggestionIndex = [];

  // utility to initialize the token index
  const hydrateIndex = (index, i) => {
    if (!index[i]) {
      index[i] = {
        alignment: null,
        // TRICKY: tokens may be suggested that have already been used resulting in multiple matches.
        suggestions: []
      };
    }
    return index;
  };

  // index to alignments
  for (let a = 0; a < alignments.length; a++) {
    // index source tokens
    const sourceTokens = alignments[a].sourceNgram;
    for (let t = 0; t < sourceTokens.length; t++) {
      const position = sourceTokens[t];
      hydrateIndex(sourceTokenIndex, position);
      sourceTokenIndex[position].alignment = a;

      // perform general indexing of alignments
      const sourceLength = alignments[a].sourceNgram.length;
      alignmentIndex.push({
        index: a,
        aligned: alignments[a].targetNgram.length > 0,
        sourceLength,
        targetLength: alignments[a].targetNgram.length,
        isEmpty: alignments[a].targetNgram.length === 0,
        sourceId: alignments[a].sourceNgram.join(),
        targetId: alignments[a].targetNgram.join(),
        targetNgram: alignments[a].targetNgram,
        lastSourceToken: alignments[a].sourceNgram[sourceLength - 1]
      });
    }
    // index target tokens
    const targetTokens = alignments[a].targetNgram;
    for (let t = 0; t < targetTokens.length; t++) {
      const position = targetTokens[t];
      hydrateIndex(targetTokenIndex, position);
      targetTokenIndex[position].alignment = a;
    }
  }

  // index to suggestions
  for (let s = 0; s < suggestions.length; s++) {
    // index source tokens
    const sourceTokens = suggestions[s].sourceNgram;
    for (let t = 0; t < sourceTokens.length; t++) {
      const position = sourceTokens[t];
      hydrateIndex(sourceTokenIndex, position);
      sourceTokenIndex[position].suggestions.push(s);

      // perform general indexing of suggestions
      const sourceLength = suggestions[s].sourceNgram.length;
      suggestionIndex.push({
        index: s,
        sourceLength,
        targetLength: suggestions[s].targetNgram.length,
        isEmpty: suggestions[s].targetNgram.length === 0,
        sourceId: suggestions[s].sourceNgram.join(),
        targetId: suggestions[s].targetNgram.join(),
        targetNgram: suggestions[s].targetNgram,
        lastSourceToken: suggestions[s].sourceNgram[sourceLength - 1]
      });
    }
    // index target tokens
    const targetTokens = suggestions[s].targetNgram;
    for (let t = 0; t < targetTokens.length; t++) {
      const position = targetTokens[t];
      hydrateIndex(targetTokenIndex, position);
      targetTokenIndex[position].suggestions.push(s);
    }
  }

  return {
    source: sourceTokenIndex,
    target: targetTokenIndex,
    // TODO: some day if we re-write the renderer this may be helpful
    // alignments: alignmentIndex,
    // suggestions: suggestionIndex
  };
};

/**
 * Generates an index of suggestions associated with each alignment.
 * This is the inverse of {@link indexSuggestionAlignments}
 * @param {object} tokenIndex - an index generated by {@link indexTokens}
 * @return {object} - the index
 */
export const indexAlignmentSuggestions = tokenIndex => {
  const alignmentIndex = {};

  for (let t = 0; t < tokenIndex.source.length; t++) {
    const tempIndex = tokenIndex.source[t]; // index of a single token
    const alignmentPos = tempIndex.alignment;
    if (!alignmentIndex[alignmentPos]) {
      alignmentIndex[alignmentPos] = [];
    }
    alignmentIndex[alignmentPos].push(...tempIndex.suggestions);
  }

  return alignmentIndex;
};

/**
 * Generates an index of alignments associated with each suggestion.
 * This is the inverse of {@link indexAlignmentSuggestions}
 * @param {object} alignmentSuggestionsIndex - the index generated by {@link indexAlignmentSuggestions}
 * @return {object} - the index
 */
export const indexSuggestionAlignments = alignmentSuggestionsIndex => {
  const suggestionIndex = {};

  const numAlignments = Object.keys(alignmentSuggestionsIndex).length;
  for (let a = 0; a < numAlignments; a++) {
    for (let s = 0; s < alignmentSuggestionsIndex[a].length; s++) {
      const suggestionPos = alignmentSuggestionsIndex[a][s];
      if (!suggestionIndex[suggestionPos]) {
        suggestionIndex[suggestionPos] = [];
      }
      suggestionIndex[suggestionPos].push(a);
    }
  }

  return suggestionIndex;
};

/**
 * Renders the verse alignments with the suggestions
 * @param {object[]} alignments - an array of alignments
 * @param {object[]} suggestions - an array of alignment suggestions
 * @param {number} numSourceTokens - the number of source tokens in the verse
 * @return the alignments rendered with suggestions.
 */
const render = (alignments, suggestions, numSourceTokens) => {
  // index things
  const tokenIndex = indexTokens(alignments, suggestions);
  const alignmentSuggestionsIndex = indexAlignmentSuggestions(tokenIndex);
  validateAlignments(alignments, numSourceTokens, "Pre-RenderedAlignments ");

  const alignmentSourceIndex = [];
  const suggestionSourceIndex = [];
  const targetIndex = {};
  for (let aIndex = 0; aIndex < alignments.length; aIndex++) {
    for (const pos of alignments[aIndex].targetNgram) {
      targetIndex[pos] = aIndex;
    }
    const sourceLength = alignments[aIndex].sourceNgram.length;
    for (let i = 0; i < sourceLength; i++) {
      // TRICKY: the source tokens may not be in order in case of discontiguous source tokens, so we need to sort
      alignmentSourceIndex.push({
        index: aIndex,
        sort: alignments[aIndex].sourceNgram[i],
        aligned: alignments[aIndex].targetNgram.length > 0,
        sourceLength,
        targetLength: alignments[aIndex].targetNgram.length,
        isEmpty: alignments[aIndex].targetNgram.length === 0,
        sourceId: alignments[aIndex].sourceNgram.join(),
        targetId: alignments[aIndex].targetNgram.join(),
        targetNgram: alignments[aIndex].targetNgram,
        lastSourceToken: alignments[aIndex].sourceNgram[sourceLength - 1]
      });
    }
  }
  alignmentSourceIndex.sort(objectComparator);
  
  for (let sIndex = 0; sIndex < suggestions.length; sIndex++) {
    const sourceLength = suggestions[sIndex].sourceNgram.length;
    for (let i = 0; i < sourceLength; i++) {
      // TRICKY: the source tokens may not be in order in case of discontiguous source tokens, so we need to sort
      suggestionSourceIndex.push({
        index: sIndex,
        sort: suggestions[sIndex].sourceNgram[i],
        sourceLength,
        targetLength: suggestions[sIndex].targetNgram.length,
        isEmpty: suggestions[sIndex].targetNgram.length === 0,
        sourceId: suggestions[sIndex].sourceNgram.join(),
        targetId: suggestions[sIndex].targetNgram.join(),
        targetNgram: suggestions[sIndex].targetNgram,
        lastSourceToken: suggestions[sIndex].sourceNgram[sourceLength - 1]
      });
    }
  }
  suggestionSourceIndex.sort(objectComparator);

  // TRICKY: we don't support partial suggestion coverage at the moment
  if (suggestionSourceIndex.length > 0 && suggestionSourceIndex.length !==
    numSourceTokens) {
    console.error(
      'Index out of bounds. We currently do not support partial suggestions.');
    return [...convertToRendered(alignments)];
  }

  // TRICKY: short circuit invalid alignments
  if (alignmentSourceIndex.length !== numSourceTokens) {
    console.error(`Alignments are corrupt. Expected ${numSourceTokens} but received ${alignmentSourceIndex.length}`, alignments, suggestions);
    return [...convertToRendered(alignments)];
  }

  // build output
  const suggestedAlignments = [];
  let alignmentQueue = []; // track how many alignments span a suggestion
  let suggestionStateIsValid = true;
  for (let i = 0, alignLen = alignments.length; i < alignLen; i++) {
    const alignment = alignments[i];
    for (let j = 0, srcLen = alignment.sourceNgram.length; j < srcLen; j++) {
      const tIndex = alignment.sourceNgram[j];
      if (tIndex < 0 || tIndex >= numSourceTokens) {
        continue;
      }

      const alignmentPos = alignmentSourceIndex[tIndex].index;
      if (alignmentQueue.indexOf(alignmentSourceIndex[tIndex].index) === -1) {
        alignmentQueue.push(alignmentSourceIndex[tIndex].index);
      }

      const alignmentIsAligned = alignmentSourceIndex[tIndex].aligned;
      const finishedReadingAlignment = alignmentSourceIndex[tIndex].lastSourceToken ===
        tIndex;
      const suggestionSpansMultiple = alignmentQueue.length > 1;

      let targetUsedElsewhere = false;

      // determine suggestion validity
      let suggestionIsValid = false;
      let finishedReadingSuggestion = false;
      let sourceNgramsMatch = false;
      // TRICKY: we may not have suggestions for everything
      if (tIndex < suggestionSourceIndex.length) {
        // check if suggested target tokens are already used
        for (const targetPos of suggestionSourceIndex[tIndex].targetNgram) {
          if (targetPos in targetIndex) {
            const index = targetIndex[targetPos];
            targetUsedElsewhere = alignmentQueue.indexOf(index) === -1;
            if (targetUsedElsewhere) {
              break;
            }
          }
        }

        finishedReadingSuggestion = suggestionSourceIndex[tIndex].lastSourceToken ===
          tIndex;
        const suggestionTargetIsSuperset = isSubArray(
          suggestionSourceIndex[tIndex].targetNgram,
          alignmentSourceIndex[tIndex].targetNgram);

        sourceNgramsMatch = alignmentSourceIndex[tIndex].sourceId ===
          suggestionSourceIndex[tIndex].sourceId;
        const targetNgramsMatch = alignmentSourceIndex[tIndex].targetId ===
          suggestionSourceIndex[tIndex].targetId;
        const isPerfectMatch = sourceNgramsMatch && targetNgramsMatch;
        const alignmentIsMerged = alignmentSourceIndex[tIndex].sourceLength > 1;

        const suggestionIsEmpty = suggestionSourceIndex[tIndex].isEmpty;
        let siblingSuggestionsAreEmpty = suggestionIsEmpty;
        const siblings = alignmentSuggestionsIndex[alignmentPos];
        if (suggestionIsEmpty && siblings) {
          for (let i = 0; i < siblings.length; i++) {
            if (suggestions[siblings[i]].targetNgram.length > 0) {
              siblingSuggestionsAreEmpty = false;
            }
          }
        }

        if (siblingSuggestionsAreEmpty) {
          // empty suggestions are always in-valid
          suggestionIsValid = false;
        } else if (!alignmentIsAligned && !alignmentIsMerged) {
          // TRICKY: for now we do not allow splitting merged alignments
          // un-aligned alignments are valid
          suggestionIsValid = true;
        } else if (!isPerfectMatch && finishedReadingAlignment &&
          finishedReadingSuggestion && !suggestionSpansMultiple &&
          suggestionTargetIsSuperset && sourceNgramsMatch) {
          // identical source n-grams are valid
          suggestionIsValid = true;
        } else if (!isPerfectMatch && !finishedReadingAlignment &&
          !finishedReadingSuggestion && !suggestionSpansMultiple &&
          suggestionTargetIsSuperset) {
          // incomplete readings are valid until proven otherwise
          suggestionIsValid = true;
        }
      }

      // TRICKY: persist invalid state through the entire suggestion.
      if (!suggestionIsValid) {
        suggestionStateIsValid = suggestionIsValid;
      }

      // renders a finished alignment
      const renderAlignment = () => {
        // use the alignment
        const index = alignmentQueue.pop();
        const rawAlignment = _.cloneDeep(alignments[index]);
        rawAlignment.alignments = [index];
        rawAlignment.sort = rawAlignment.sourceNgram && rawAlignment.sourceNgram.length && rawAlignment.sourceNgram[0] || 0;
        return rawAlignment;
      };

      // renders a finished suggestion
      const renderSuggestion = () => {
        const index = suggestionSourceIndex[tIndex].index;
        // merge target n-grams
        const rawSuggestion = _.cloneDeep(suggestions[index]);
        rawSuggestion.suggestedTargetTokens = [...rawSuggestion.targetNgram];
        for (const aIndex of alignmentQueue) {
          const rawAlignment = alignments[aIndex];
          for (const t of rawAlignment.targetNgram) {
            if (rawSuggestion.targetNgram.indexOf(t) === -1) {
              rawSuggestion.targetNgram.push(t);
            } else {
              _.pull(rawSuggestion.suggestedTargetTokens, t);
            }
          }
          rawSuggestion.targetNgram = _.union(rawSuggestion.targetNgram,
            rawAlignment.targetNgram);
        }
        rawSuggestion.alignments = [...alignmentQueue];
        rawSuggestion.suggestion = index;
        rawSuggestion.targetNgram.sort(numberComparator);
        rawSuggestion.sort = rawSuggestion.sourceNgram && rawSuggestion.sourceNgram.length && rawSuggestion.sourceNgram[0] || 0;
        if (suggestionSourceIndex[tIndex].isEmpty && sourceNgramsMatch) {
          // TRICKY: render empty matches as an alignment
          return {
            alignments: rawSuggestion.alignments,
            sort: rawSuggestion.sort,
            sourceNgram: rawSuggestion.sourceNgram,
            targetNgram: rawSuggestion.targetNgram
          };
        } else {
          return rawSuggestion;
        }
      };

      // TRICKY: if the suggested target tokens are used elsewhere we render the alignment
      const shouldRenderSuggestion = suggestionStateIsValid &&
        finishedReadingSuggestion && !targetUsedElsewhere;
      const shouldRenderAlignment = (!suggestionStateIsValid ||
        targetUsedElsewhere) && finishedReadingAlignment;

      // append finished readings
      if (shouldRenderSuggestion) {
        suggestedAlignments.push(renderSuggestion());
      } else if (shouldRenderAlignment) {
        suggestedAlignments.push(renderAlignment());
      }

      // clean up
      if (!suggestionStateIsValid && finishedReadingAlignment ||
        suggestionStateIsValid && finishedReadingSuggestion) {
        alignmentQueue = [];
      }
      if (finishedReadingSuggestion) {
        suggestionStateIsValid = true;
      }
    }
  }

  suggestedAlignments.sort(objectComparator);
  validateAlignments(suggestedAlignments, numSourceTokens, "renderedAlignments");
  return suggestedAlignments;
};

/**
 * does a sanity check on alignments - adds entries to log file on alignment/rendering errors
 * @param {[Object]} alignments
 * @param {Number} numSourceTokens
 * @param {String} title - identifier of alignment being validated
 */
function validateAlignments(alignments, numSourceTokens, title) {
  try {
    const sourceIndices = [];
    let lastAlignStart = -1;
    for (let i = 0, alignLen = alignments.length; i < alignLen; i++) {
      const alignment = alignments[i];
      const alignStart = alignment.sourceNgram[0];
      if (alignStart <= lastAlignStart) {
        console.error(`'${title}' alignment start primary word ${alignStart} should be greater than last alignment ${lastAlignStart}`);
      }
      lastAlignStart = alignStart;
      
      let lastIndex = -1;
      for (let j = 0, srcLen = alignment.sourceNgram.length; j < srcLen; j++) {
        const tIndex = alignment.sourceNgram[j];
        if (tIndex < 0) {
          console.error(`'${title}' primary word ${tIndex} is invalid`);
        }
        if (tIndex >= numSourceTokens) {
          console.error(`'${title}' primary word ${tIndex} is too large`);
        }
        if (tIndex <= lastIndex) {
          console.error(`'${title}' primary word ${tIndex} should be greater than last word ${lastIndex}`);
        }
        if (sourceIndices.includes(tIndex)) {
          console.error(`'${title}' duplicate primary word: ${tIndex}`);
        }
        sourceIndices.push(tIndex);
        lastIndex = tIndex;
      }
    }
    for (let k = 0; k < numSourceTokens; k++) {
      if (!sourceIndices.includes(k)) {
        console.error(`'${title}' is missing primary word: ${k}`);
      }
    }
  } catch(e) {
    console.error(`'${title}' validation error`, e);
  }
}

export default render;

/**
 * Converts some alignments to rendered alignments.
 * @param alignments
 * @return {*}
 */
export const convertToRendered = (alignments) => {
  return alignments.map((a, index) => {
    const newA = _.cloneDeep(a);
    newA.alignments = [index];
    return newA;
  });
};

/**
 * Checks if an array if a subset of another
 * @param superset
 * @param subset
 * @return {boolean}
 */
const isSubArray = (superset, subset) => {
  for (const val of subset) {
    if (!_.includes(superset, val)) {
      return false;
    }
  }
  return true;
};
